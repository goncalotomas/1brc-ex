defmodule Brc do
  @moduledoc """
  The main module for the escript generated by `mix escript.build`.
  Currently set to running solution `Alpha` by defualt, this may be
  changed using the `-m` or the `--module` command line argument.

  Additionally, the number of worker processes is also read from the
  `-p` or the `--processes` argument and is stored in Application env.
  Keep in mind the selected solution might not support a dynamic number
  of worker processes, this is meant as a utility to make it easier to
  run multiple tests to evaluate optimal parameters.
  """
  require Logger

  @implementation_module Brc.Implementation.Charlie

  @switches [
    processes: :integer,
    module: :string
  ]

  @switch_aliases [
    p: :processes,
    m: :module
  ]

  def main(args) do
    start = System.monotonic_time(:millisecond)

    {opts, [path]} = OptionParser.parse!(args, switches: @switches, aliases: @switch_aliases)

    for {option, value} <- opts do
      Application.put_env(:brc, option, value)
    end

    module = Keyword.get(opts, :module, @implementation_module)

    case apply(module, :run, [path]) do
      {:ok, results} ->
        print_results!(results)

      {:error, reason} ->
        IO.puts("There was an error: #{reason}")
    end

    seconds = Float.ceil((System.monotonic_time(:millisecond) - start) / 1000, 2)
    IO.puts("Execution time: #{seconds} seconds")
  end

  defp print_results!(results) do
    results =
      results
      |> Enum.to_list()
      |> Enum.sort_by(fn {k, _v} -> k end)

    IO.write("{")
    print_results_rec!(results)
    IO.puts("}")
  end

  defp print_results_rec!([{city, measurements}]) do
    {min, max, sum, count} = measurements
    IO.write("#{city}=#{min}/#{Float.ceil(sum / count, 1)}/#{max}")
  end

  defp print_results_rec!([{city, measurements} | tail]) do
    {min, max, sum, count} = measurements
    IO.write("#{city}=#{min}/#{Float.ceil(sum / count, 1)}/#{max}, ")
    print_results_rec!(tail)
  end
end
